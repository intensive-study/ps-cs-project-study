# 동기화

### 1. 프로세스 동기화(Synchronization) 개념

* 하나의 자원을 한 순간에 하나의 프로세스만이 이용하도록 제어하는 것

* 데이터의 일관성 유지를 위해 필요함

* 경쟁 상황(race condition)으로부터 보호하기 위해

  -경쟁상황 : 동시에 여러개 프로세스가 동일한 자료를 접근/조작하고 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황

<br/>

### 2. 임계구역 (Critical Section)

- 임계구역 : 공유 자원에 접근하는 코드의 일부. 

  ​		-각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가 요청 필요함.(entry section). 

  ​		-한 프로세스가 자신의 임계구역에서 수행하는 동안 다른 프로세스들은 그들의 임계구역에 들어갈 수 없음.

  ​		-임계구역에서 코드 실행 마친 후 임계구역 나오기 전 실행하는 코드(exit section)

  ​		

  ```python
  while true {
  	[entry section]
  		critical section
  	[exit section]
  		remainder section
  }
  ```

- 임계 구역 문제 : 임계 구역으로 지정돼야할 코드 영역이 임계구역으로 지정되지 않았을 때 발생 가능한 문제

  -프로세스들이 데이터를 협력적으로 공유하기위해 자신들의 활동을 동기화할때 사용할수있는 프로토콜 설계하는 것.

- 임계구역 문제 해결안

  - 요구 조건

    ① 상호 배제(mutual exclution) : 프로세스가 자기의 임계구역에서 실행되면, 다른 프로세스들은 그들 자신의 임계구역에서 실행 될 수 없다.

    ② 진행(progress) : 임계구역에서 실행되는 프로세스 없고 그들 자신의 임계구역으로 진입하려는 프로세스들이 있다면, 나머지 구역에서 실행중이지 않는 프로세스들만 다음에 누가 그 임계구역을 진입할 수 있는지를 결정하는 데 참여할 수 있으며, 이 선택은 무한정 연기될 수 없다.

    ③ 한정된 대기(bounded waiting) : 다른 프로세스의 기아 방지위해 한번 임계 구역에 들어간 프로세스는 다음 번 임계구역에 들어갈 때 제한 두어야 한다.

  - 접근법

    1. 선점형 커널
       - 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용.
       - 더 민첩한 응답
       - 공유되는 커널 자료구조에서의 경쟁조건 고려한 설계 필요
    2. 비선점형 커널
       - 커널 모드에서 수행되는 프로세스의 선점 허용X, 커널 모드 프로세스는 커널을 빠져나갈 때까지 또는 봉쇄될 때까지 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.

  - Peterson's Solution

    - critical section과 remainder section을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다. 두 프로세스가(P0, P1)이 두개의 데이터 항목을 공유하도록 하여 해결한다.

    - ```python
      while true{
      	flag[i] = true;
          turn = j;
          while flag[j] && turn == j
          	;
          	/* critical section */
          flag[i] = false;
          	/* remainder section */    
      }
      ```

      **flag[j]가 false(Pj가 remainder section 수행)가 되거나 turn이 i(Pj는 준비완료됬고, Pi가 Entry Section에서 대기하고 있음)일 경우 Pi는 Critical Section에 들어갈 수 있다.**

      요구조건 ① - flag[2]와 turn 변수에 의해서 하나의 프로세스만 Critical Section에서 연산을 수행할 수 있음으로 Mutual Exclusion는 지켜진다.

      요구조건 ② - 각 프로세스가 자신이 Critical Section을 수행할 동안 while문에서 다른 프로세스를 유한하게 대기하도록 만드는 방법을 통하여 Progress를 지킬 수 있다.

      요구조건 ③ - 각 프로세스들은 Critical Section에 진입하려는 요청을 한 후부터 다른 프로세스가 Critical Section을 수행하는 동안 유한하게 대기함으로 bounded waiting 또한 지켜진다.

<br/>



### 3. 바쁜 대기(Busy Waiting)

특정 공유 자원에 대해 두 개 이상의 프로세스나 스레드가 이용 권한을 획득하고자 하는 동기화 상황에서 무한 루프를 돌며 쓸데없이 cpu자원을 낭비하며 대기하는 현상.

뮤텍스나 세마포어 등을 사용하면 바쁜 대기를 하지 않을 수 있다.

<br/>

### 4. Hardware-based Solutions

 1. 메모리 장벽

    메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공하여 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장하는 명령어.

 2. 하드웨어 명령어

    한 워드(word)의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환(swap)할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어.

 3. 원자적 변수

    카운터가 증가할 때와 같이 갱신되는 동안 단일 변수에 대한 데이터 경쟁이 있을 수 있는 상황에서 상호 배제를 보장하는데 사용할 수 있다.

<br/>

### 5. Mutex Locks

- critical section을 해결하기 위한 하드웨어 기반의 해결책보다 상위 수준의 해결책.
- critical section 보호, racing condition 방지
- **공유된 자원의 데이터를 1개의 프로세스/스레드가 접근하는 것**

**프로세스는 Critical Section에 들어가기 전에 반드시 lock을 획득해야 하고 Critical Section을 빠져나올 때 lock을 반환해야 한다.**

- Critical Section 문제 해결 알고리즘

```
while true {
	[acquire lock]
		critical section
	[release lock]
		remainder section
}
```

- 단점 : 바쁜 대기 - 프로세스가 임계구역에 있는 동안 임계구역에 들어가기 원하는 다르 프로세스들이 acquire 호출하는 반복문 계속실행하여 바쁜 대기 발생

  <br/>

- ##### 스핀락(spinlock)

  바쁜 대기를 사용하는 뮤텍스 락

  락을 사용할 수 있을 때까지 프로세스가 회전한다.

  - 멀티코어 시스템에서 사용됨.
  - 프로세스가 락을 기다려야 하고 문맥 교환에 시간이 소요될 때 문맥 교환 필요하지 않다는 장점.
  - 락이 유지되는 기간이 문맥교환을 두번(1.스레드를 대기상태로, 2. 대기중인 스레드를 복원) 하는 시간보다 짧은 경우 사용
  
  > 스핀락 

<br/>

### 6.  세마포어(Semaphore)

- semaphore S : 정수 변수, 초기화 제외하고 단지 두개의 표준 원자적 연산 **wait()**(*or P()*)와 **signal()**(*or V()*)로만 접근할 수 있다.

- **공유된 자원의 데이터를 세마포어의 변수만큼의 프로세스가 접근하는 것**

- ```
  wait(S){                                            signal(S){
  	while (S <= 0)									S++;
  		; // busy wait							}						
  	S--;
  }
  ```

- 종류

  - binary semaphore : mutex lock과 유사, 0-1범위
  - counting semaphore : 제한없는 영역, 유한한 개수 가진 자원에 대한 접근 제어에 사용
    - 0 : 모든 자원 사용중.

- Critical Section 문제 해결 알고리즘을 위한 세마포어

  busy waiting 피하기 위해 세마포어S 대기하면서 일시 중지된 프로세스는 다른 프로세스가 signal()연산을 실행하면 재시작함. (sleep()연산 일시 중지, wakeup()연산 재시작)

  - wait() : 세마포어 S 음수, 대기
  - signal() : 재시작, 준비큐에 있음

> ***뮤텍스와 세마포어의 차이점***
>
> - *세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스(또는 쓰레드)가 접근할 수 있습니다.*
>   *반면에 뮤텍스는 오직 1개만의 프로세스(또는 쓰레드)만 접근할 수 있습니다.*
>
> - *현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다.* 
>   *하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.*

<br/>

### 7. 모니터(Monitors)

- mutex lock/semaphore에서 타이밍 오류 발생 가능 -> 간단한 동기화 도구 통합하여 고급 언어 구조물 모니터 제공해 처리 가능
- 하나의 프로세스 내의 다른 스레드 간 동기화에 사용
- Java에 있다.
- 세마포어와 달리 wait, signal 설정 없이 함수 앞에 synchronized를 붙여주면 상호 배제하여 함수의 작업 수행



> ***뮤텍스와 모니터의 차이점***
>
> *뮤텍스는 다른 프로세스 간에 동기화할 때 사용*
> *모니터는 하나의 프로세스 내에서 다른 스레드 간의 동기화에 사용*



<br/>

### 8. 라이브니스(Liveness)

1. 교착 상태(Deadlock)

   대기 큐 가진 Semaphore 구현은 두개이상의 프로세스들이 대기중인 프로세스들 중 하나에 의해서만 야기될 수 있는 signal()연산을 무한정 기다리는 상황 발생했을 때 프로세스들의 상태.

   

2. 우선순위 역전 (Priority Inversion)

   높은 우선순위의 프로세스가 낮은 우선순위의 프로세스로 인하여 수행이 "블록" 되어있는 상태.

   공유자원의 동기화로 인하여 발생하는 것이며, 우선순위 역전현상은 필연적으로 발생됨.



<br/>

---------

### *References*

https://imbf.github.io/computer-science(cs)/2020/11/04/Synchronization-Tools.html





