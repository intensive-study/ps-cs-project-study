# Database

1. 키
2. SQL JOIN
2. SQL vs NoSQL
2. 정규화 vs 반정규화



<br/>

## Key

데이터를 식별하고 원하는 값을 얻을 수 있다. 특정 데이터를 검색하거나 정렬할 수 있는 속성 값. 중복되지 않게 이상 현상(Anomaly : 삽입 이상, 삭제 이상, 수정 이상 등)을 방지한다.

- 유일성 : 하나의 키 값으로 하나의 튜플 식별된다.
- 최소성 : 유일성이 유지되는 최소의 속성으로 구성된다.

### 01. Key 종류

![db_key](https://user-images.githubusercontent.com/33693066/143180415-1f41a9ea-dad0-43dd-a819-03fcf4494987.PNG)

- **슈퍼키(Super Key)** : 유일성을 만족하며 한 개 이상의 속성들의 집합, 최소성을 만족하지 못하며 후보키와 기본키가 속한다.
- **후보키(Candidate Key)** : 유일성과 최소성을 만족하는 키, 기본키와 대체키의 집합으로 여기서 주 식별자로 선택된 값이 기본키이다.
- **기본키(Primary Key)** : 유일성과 최소성을 만족하며 후보키에서 대표로 지정된 키. Null 값이나 중복된 값을 가질 수 없다.
- **외래키(Foreign Key)** : 두 개 이상의 릴레이션에서 어떤 릴레이션의 기본키를 참조하는 경우 외래키라고 하며, 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값을 사용할 수 없다. (⇒ 참조 무결성 제약을 만족해야한다.)
- **부분키(Partition Key)** : 약한 개체를 유일하고 최소로 구분해 낼 수 있는 키.(구별자)

<br/>

> <*>면접 질문목록
>
> 스키마, DBMS 종류, Nosql, 크롤링데이터, 트랜잭션 데드락 핸들링, ACID(원자성,...) 컨트롤, 정규화 부분

<br/>

### 02. 이상(Anomaly)

- 삽입 이상
  
    데이터를 삽입할 때 불필요한 데이터를 추가해야하는 현상
    
- 삭제 이상
  
    한 튜플을 삭제할 때 다른 값이 함께 삭제되는 현상
    
- 갱신 이상
  
    갱신이 필요한 튜플을 모두 변경하지 않아서 생기는 이상 현상
    
    <br/>

### *  용어 정리

| 파일 시스템 | DB 모델링 [단위] | 관계형 DB |
| --- | --- | --- |
| File | Entity | Table |
| Record | Tuple [cadinality] | Row |
| Field | Attribute [degree] | Column |
| Key | Identifier | Primary Key/Unique |

Domain : 속성 값에 들어갈 수 있는 값의 범위

<br/>

### 03. 무결성 제약(Integrity Constraint)

- 개체 무결성 제약
  
    기본키를 구성하는 속성 값에는 Null값이나 중복 값을 가지지 못한다.
    
- 참조 무결성
  
    릴레이션 R1에 저장된 튜플이 다른 릴레이션(R0)에 있는 튜플을 참조하려면 해당 릴레이션(R0)에 반드시 튜플이 존재해야한다. 외래키는 참조 릴레이션의 기본키로 존재하고 두 키(외래키, 참조된 기본키) 간에 도메인과 속성 갯수 또한 일치해야 한다.
    
- 도메인 무결성
  
    주어진 속성 값이 해당 속성에 정의된 도메인에 속해야한다.
    
    <br/><br/>

## SQL JOIN

두 개의 릴레이션을 공통 속성을 기준으로 묶어 새로운 릴레이션을 생성하는 연산

(예시는 [링크](https://github.com/OnewayYoun/ps-cs-project-study/blob/main/CS/Database/SQL%20JOIN%20%EC%98%88%EC%8B%9C.md) 참조)

- 외부 조인(Outer Join)
  
    내부 조인을 확장한 개념으로 릴레이션에 있는 튜플에 조인할 상대 릴레이션 튜플이 대응되지 않으면 Null 튜플로 생성한다. 기준이 되는 릴레이션은 left / right / 전체로 지정할 수 있다.
    
    좌측을 지정한 경우 먼저 나오는 릴레이션 튜플을 모두 활용, 우측은 이후에 나온 릴레이션 튜플을 기준으로 새로운 릴레이션을 생성한다.
    
- 내부 조인(Inner Join)
  
    두 릴레이션의 공통된 값을 이용해 모두 존재하는 데이터만 추출해 생성하는 방법

<br/>

## SQL vs NoSQL

|           | SQL DB                                                       | NoSQL DB                                                     |
| --------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 정의      | **RDBMS**(관계형 데이터베이스 관리 시스템)의 데이터를 관리하기 위해 설계된 프로그래밍 언어 | **비관계형** 형식의 데이터를 관리하는 방법을 제공하는 데이터베이스 |
| 특징      | 1. 정해진 데이터 스키마에 따라 테이블에 저장됨.<br />2. 관계를 통해 여러 테이블에 분산됨.<br />3. 조인(JOIN)<br /> | 1. Document 구조<br />2. 다른 구조의 데이터를 같은 컬렉션에 추가 가능함.<br />3. 조인(JOIN) 개념 없음.<br />4. 수평적 확장(서버 추가로 DB 분산시킴) |
| 장점      | - 명확히 정의된 스키마<br />- 데이터 무결성 보장<br />- 데이터를 중복없이 한번만 저장함. | - 스키마 없어 유연함.<br />- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨.<br />- 수직/수평적 확장 가능 -> 모든 r/w 요청 가능 |
| 단점      | - 덜 유연함.<br />- 관계로 인해 조인문 많은 복잡한 쿼리 발생 가능.<br />- 수직적 확장 | - 유연성으로 인해 데이터 구조 결정 미루게 됨.<br />- 데이터 중복 계속 업데이트 필요함.<br />- 여러 컬렉션에 데이터가 중복되어 있으므로 수정 시 모든 컬렉션에서 수행해야 함. |
| 속성      | **ACID properties**<br />- *Atomicity(원자성)* : 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것이다. (불가능한 최소의 단위인 하나의 원자처럼 동작한다는 의미이다.) <br />- *Consistency(일관성)* : 미리 정의된 규칙에서만 수정이 가능한 특성을 의미한다. (숫자 컬럼에 문자열값이 저장이 안되도록 보장한다.)  <br />- *Isolation(고립성)* : 트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것이다. <br />- *Durability(영구성)* : 성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 의미한다. (한번 반영(commit)된 트랜젝션의 내용은 영원히 적용된다.) | **CAP theorem**<br />(오직 2가지만 만족 가능)<br />- *Consistency (일관성)* : 모든 요청은 최신 데이터 또는 에러를 응답받는다. (DB가 3개로 분산되었다고 가정할 때, 하나의 특정 DB의 데이터가 수정되면 나머지 2개의 DB에서도 수정된 데이터를 응답받아야 한다.) <br />- *Availability (가용성)* : 모든 요청은 정상 응답을 받는다. (특정 DB가 장애가 나도 서비스가 가능해야 한다.) <br />- *Partitions Tolerance (분리 내구성)* : DB간 통신이 실패하는 경우라도 시스템은 정상 동작 한다. |
| 사용 예시 | - 데이터가 자주 변경되는 애플리케이션<br />- 변경 예정 없고 스키마 명확해야 하는 경우 | - 정확한 데이터 구조 모르거나 변경/확장 필요할 때<br />- 자주 읽기를 실행하나, 데이터 변경 자주 없을 경우<br />- 막대한 양의 데이터 다뤄야 하는 경우(db 수평적 확대) |

<br/>

## 정규화 vs 반정규화

### 정규화 *Normalization*

중복을 최소화하도록 설계된 데이터베이스

- 원칙

  - 데이터의 중복성이 감소

  - 정보의 무손실 표현 → 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안 된다.

  - 분리의 원칙 → 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.

- 장/단점

  | 장점                                                         | 단점                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | - 이상 현상 해결<br />- 저장 공간의 최소화 가능<br />- 데이터 삽입 시 릴레이션 재구성의 필요성 감소<br />- 데이터 구조의 안정성 및 무결성 유지 | - 릴레이션 분해로 연산 증가해 응답시간 느려질 수 있음 <br />→ *"반정규화로 성능 향상"* |

  

##### 정규화 과정
![norm](https://user-images.githubusercontent.com/33693066/143280917-1fe16959-0786-47aa-991d-90adbad1e20a.PNG)

(예제 설명은 [링크1](https://chankim.tistory.com/9), [링크2](https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80) 참고)

1. **1NF**

   테이블에 각 도메인은 원자성을 가진다. (각 셀이 더 작게 나눌 수 없는 단일값을 가진다.)

2. **2NF **

   1NF 충족 + 테이블의 모든 컬럼이 완전 함수 종속을 만족(기본키가 아닌 모든 속성이 기본키에 완전 함수 종속)

   > - 완전 함수 종속 : 기본키 {x1, x2, x3}(결정자) 모두에 의해서 Y(종속자) 값이 결정될 경우
   > - 부분 함수적 종속 : 기본키 {x1, x2, x3} 중 {x1}에 의해서만 Y값이 결정될 경우
   > - 이행적 함수적 종속 : X → Y이고 Y → Z 는 X → Z이다.
   > - 다치 종속 : (X, Z)에 대응되는 Y의 집합이 X에만 종속되고 Z에는 독립적이면 Y는 X에 다치 종속, X ↠Y

3. **3NF **

   2NF 충족 + 모든 속성이 기본키(복합키)에 이행적 함수 종속이 되지 않아야 한다.(기본키가 아닌 속성들은 기본키에만 의존한다.)

   - 3NF 충족하도록 변경하려면 (X → Y), (Y → Z) 테이블로 분리하면 된다.

4. **BCNF**

   BCNF는 3NF를 만족하면서 함수 종속성 X->Y가 성립할 때 모든 결정자 X가 후보키인 정규형(모든 결정자가 후보키 집합에 속한 정규형)

   

<br/>

### 반정규화(비정규화) *Denormalization*

읽기 성능 향상을 위해 설계된 데이터베이스.

읽기 작업이 많이 필요한 성능문제가 있는 테이블 때문.

시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, **의도적으로 정규화 원칙을 위배하는 행위**

- 대상

  - 디스크 I/O 량이 많아서 조회 시 성능이 저하될 때.
  - 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상될 때
  - 칼럼을 계산하여 조회할 때 성능이 저하될 것이 예상될 때

- 장단점

  | 장점                                                         | 단점--                                                       |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | - 빠른 데이터 조회→ 조인 비용이 줄어들기 때문<br />- 살펴볼 테이블이 줄어들기 때문에 데이터 조회 쿼리가 간단해짐→ 따라서 버그 발생 가능성도 줄어든다 | - 데이터 갱신이나 삽입 비용이 높음<br />- 데이터 갱신 또는 삽입 코드를 작성하기 어려워짐<br />- 데이터를 중복하여 저장하므로 더 많은 저장 공간이 필요<br />- 데이터 간의 일관성 손상 가능 |

- 주의점

  - 과도한 적용은 데이터 무결성이 깨질 수 있다.
  - 응답 시간 늦어질 수 있다.
  - 저장공간 효율 감소
  - 유지보수 어려움.





<br/>

<br/>

---------------

##### References

https://kosaf04pyh.tistory.com/201

https://velog.io/@thms200/SQL-vs-NoSQL

https://owlyr.tistory.com/20#bdcbaf9c-3ce5-44b6-b87a-0729a24f4123

https://velog.io/@bsjp400/Database-DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EB%B9%84%EC%A0%95%EA%B7%9C%ED%99%94%EB%9E%80
